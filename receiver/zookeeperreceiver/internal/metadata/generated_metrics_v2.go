// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/model/pdata"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for zookeeperreceiver metrics.
type MetricsSettings struct {
	ZookeeperApproximateDateSize   MetricSettings `mapstructure:"zookeeper.approximate_date_size"`
	ZookeeperConnectionsAlive      MetricSettings `mapstructure:"zookeeper.connections_alive"`
	ZookeeperEphemeralNodes        MetricSettings `mapstructure:"zookeeper.ephemeral_nodes"`
	ZookeeperFollowers             MetricSettings `mapstructure:"zookeeper.followers"`
	ZookeeperFsyncThresholdExceeds MetricSettings `mapstructure:"zookeeper.fsync_threshold_exceeds"`
	ZookeeperLatencyAvg            MetricSettings `mapstructure:"zookeeper.latency.avg"`
	ZookeeperLatencyMax            MetricSettings `mapstructure:"zookeeper.latency.max"`
	ZookeeperLatencyMin            MetricSettings `mapstructure:"zookeeper.latency.min"`
	ZookeeperMaxFileDescriptors    MetricSettings `mapstructure:"zookeeper.max_file_descriptors"`
	ZookeeperOpenFileDescriptors   MetricSettings `mapstructure:"zookeeper.open_file_descriptors"`
	ZookeeperOutstandingRequests   MetricSettings `mapstructure:"zookeeper.outstanding_requests"`
	ZookeeperPacketsReceived       MetricSettings `mapstructure:"zookeeper.packets.received"`
	ZookeeperPacketsSent           MetricSettings `mapstructure:"zookeeper.packets.sent"`
	ZookeeperPendingSyncs          MetricSettings `mapstructure:"zookeeper.pending_syncs"`
	ZookeeperSyncedFollowers       MetricSettings `mapstructure:"zookeeper.synced_followers"`
	ZookeeperWatches               MetricSettings `mapstructure:"zookeeper.watches"`
	ZookeeperZnodes                MetricSettings `mapstructure:"zookeeper.znodes"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		ZookeeperApproximateDateSize: MetricSettings{
			Enabled: true,
		},
		ZookeeperConnectionsAlive: MetricSettings{
			Enabled: true,
		},
		ZookeeperEphemeralNodes: MetricSettings{
			Enabled: true,
		},
		ZookeeperFollowers: MetricSettings{
			Enabled: true,
		},
		ZookeeperFsyncThresholdExceeds: MetricSettings{
			Enabled: true,
		},
		ZookeeperLatencyAvg: MetricSettings{
			Enabled: true,
		},
		ZookeeperLatencyMax: MetricSettings{
			Enabled: true,
		},
		ZookeeperLatencyMin: MetricSettings{
			Enabled: true,
		},
		ZookeeperMaxFileDescriptors: MetricSettings{
			Enabled: true,
		},
		ZookeeperOpenFileDescriptors: MetricSettings{
			Enabled: true,
		},
		ZookeeperOutstandingRequests: MetricSettings{
			Enabled: true,
		},
		ZookeeperPacketsReceived: MetricSettings{
			Enabled: true,
		},
		ZookeeperPacketsSent: MetricSettings{
			Enabled: true,
		},
		ZookeeperPendingSyncs: MetricSettings{
			Enabled: true,
		},
		ZookeeperSyncedFollowers: MetricSettings{
			Enabled: true,
		},
		ZookeeperWatches: MetricSettings{
			Enabled: true,
		},
		ZookeeperZnodes: MetricSettings{
			Enabled: true,
		},
	}
}

type metrics struct {
	ZookeeperApproximateDateSize   pdata.Metric
	ZookeeperConnectionsAlive      pdata.Metric
	ZookeeperEphemeralNodes        pdata.Metric
	ZookeeperFollowers             pdata.Metric
	ZookeeperFsyncThresholdExceeds pdata.Metric
	ZookeeperLatencyAvg            pdata.Metric
	ZookeeperLatencyMax            pdata.Metric
	ZookeeperLatencyMin            pdata.Metric
	ZookeeperMaxFileDescriptors    pdata.Metric
	ZookeeperOpenFileDescriptors   pdata.Metric
	ZookeeperOutstandingRequests   pdata.Metric
	ZookeeperPacketsReceived       pdata.Metric
	ZookeeperPacketsSent           pdata.Metric
	ZookeeperPendingSyncs          pdata.Metric
	ZookeeperSyncedFollowers       pdata.Metric
	ZookeeperWatches               pdata.Metric
	ZookeeperZnodes                pdata.Metric
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user configuration.
type MetricsBuilder struct {
	config                       MetricsSettings
	startTime                    pdata.Timestamp
	attributeServerStateCapacity int
	attributeZkVersionCapacity   int
	metrics                      metrics
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pdata.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

// WithAttributeServerStateCapacity sets an expected number of values of server.state attribute that will be
// used to calculate data points capacity for each metric report.
func WithAttributeServerStateCapacity(cap int) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.attributeServerStateCapacity = cap
	}
}

// WithAttributeZkVersionCapacity sets an expected number of values of zk.version attribute that will be
// used to calculate data points capacity for each metric report.
func WithAttributeZkVersionCapacity(cap int) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.attributeZkVersionCapacity = cap
	}
}

func NewMetricsBuilder(config MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:    config,
		startTime: pdata.NewTimestampFromTime(time.Now()),
	}

	for _, op := range options {
		op(mb)
	}

	mb.clearMetrics()
	return mb
}

// Emit appends generated metrics to a pdata.MetricsSlice and updates the internal state to be ready for recording
// another set of data points. This function will be doing all transformations required to produce metric representation
// defined in metadata and user configuration, e.g. delta/cumulative translation.
func (mb *MetricsBuilder) Emit(metrics pdata.MetricSlice) {
	if mb.config.ZookeeperApproximateDateSize.Enabled && mb.metrics.ZookeeperApproximateDateSize.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperApproximateDateSize.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperConnectionsAlive.Enabled && mb.metrics.ZookeeperConnectionsAlive.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperConnectionsAlive.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperEphemeralNodes.Enabled && mb.metrics.ZookeeperEphemeralNodes.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperEphemeralNodes.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperFollowers.Enabled && mb.metrics.ZookeeperFollowers.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperFollowers.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperFsyncThresholdExceeds.Enabled && mb.metrics.ZookeeperFsyncThresholdExceeds.Sum().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperFsyncThresholdExceeds.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperLatencyAvg.Enabled && mb.metrics.ZookeeperLatencyAvg.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperLatencyAvg.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperLatencyMax.Enabled && mb.metrics.ZookeeperLatencyMax.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperLatencyMax.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperLatencyMin.Enabled && mb.metrics.ZookeeperLatencyMin.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperLatencyMin.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperMaxFileDescriptors.Enabled && mb.metrics.ZookeeperMaxFileDescriptors.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperMaxFileDescriptors.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperOpenFileDescriptors.Enabled && mb.metrics.ZookeeperOpenFileDescriptors.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperOpenFileDescriptors.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperOutstandingRequests.Enabled && mb.metrics.ZookeeperOutstandingRequests.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperOutstandingRequests.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperPacketsReceived.Enabled && mb.metrics.ZookeeperPacketsReceived.Sum().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperPacketsReceived.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperPacketsSent.Enabled && mb.metrics.ZookeeperPacketsSent.Sum().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperPacketsSent.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperPendingSyncs.Enabled && mb.metrics.ZookeeperPendingSyncs.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperPendingSyncs.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperSyncedFollowers.Enabled && mb.metrics.ZookeeperSyncedFollowers.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperSyncedFollowers.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperWatches.Enabled && mb.metrics.ZookeeperWatches.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperWatches.CopyTo(metrics.AppendEmpty())
	}
	if mb.config.ZookeeperZnodes.Enabled && mb.metrics.ZookeeperZnodes.Gauge().DataPoints().Len() > 0 {
		mb.metrics.ZookeeperZnodes.CopyTo(metrics.AppendEmpty())
	}

	// Reset metric data points collection.
	mb.clearMetrics()
}

// zookeeperApproximateDateSizeMetric builds new zookeeper.approximate_date_size metric.
func (mb *MetricsBuilder) zookeeperApproximateDateSizeMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.approximate_date_size")
	metric.SetDescription("Size of data in bytes that a ZooKeeper server has in its data tree.")
	metric.SetUnit("By")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// zookeeperConnectionsAliveMetric builds new zookeeper.connections_alive metric.
func (mb *MetricsBuilder) zookeeperConnectionsAliveMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.connections_alive")
	metric.SetDescription("Number of active clients connected to a ZooKeeper server.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// zookeeperEphemeralNodesMetric builds new zookeeper.ephemeral_nodes metric.
func (mb *MetricsBuilder) zookeeperEphemeralNodesMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.ephemeral_nodes")
	metric.SetDescription("Number of ephemeral nodes that a ZooKeeper server has in its data tree.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// zookeeperFollowersMetric builds new zookeeper.followers metric.
func (mb *MetricsBuilder) zookeeperFollowersMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.followers")
	metric.SetDescription("The number of followers in sync with the leader. Only exposed by the leader.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// zookeeperFsyncThresholdExceedsMetric builds new zookeeper.fsync_threshold_exceeds metric.
func (mb *MetricsBuilder) zookeeperFsyncThresholdExceedsMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.fsync_threshold_exceeds")
	metric.SetDescription("Number of times fsync duration has exceeded warning threshold.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeSum)
	metric.Sum().SetIsMonotonic(true)
	metric.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	return metric
}

// zookeeperLatencyAvgMetric builds new zookeeper.latency.avg metric.
func (mb *MetricsBuilder) zookeeperLatencyAvgMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.latency.avg")
	metric.SetDescription("Average time in milliseconds for requests to be processed.")
	metric.SetUnit("ms")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// zookeeperLatencyMaxMetric builds new zookeeper.latency.max metric.
func (mb *MetricsBuilder) zookeeperLatencyMaxMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.latency.max")
	metric.SetDescription("Maximum time in milliseconds for requests to be processed.")
	metric.SetUnit("ms")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// zookeeperLatencyMinMetric builds new zookeeper.latency.min metric.
func (mb *MetricsBuilder) zookeeperLatencyMinMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.latency.min")
	metric.SetDescription("Minimum time in milliseconds for requests to be processed.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// zookeeperMaxFileDescriptorsMetric builds new zookeeper.max_file_descriptors metric.
func (mb *MetricsBuilder) zookeeperMaxFileDescriptorsMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.max_file_descriptors")
	metric.SetDescription("Maximum number of file descriptors that a ZooKeeper server can open.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// zookeeperOpenFileDescriptorsMetric builds new zookeeper.open_file_descriptors metric.
func (mb *MetricsBuilder) zookeeperOpenFileDescriptorsMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.open_file_descriptors")
	metric.SetDescription("Number of file descriptors that a ZooKeeper server has open.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// zookeeperOutstandingRequestsMetric builds new zookeeper.outstanding_requests metric.
func (mb *MetricsBuilder) zookeeperOutstandingRequestsMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.outstanding_requests")
	metric.SetDescription("Number of currently executing requests.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// zookeeperPacketsReceivedMetric builds new zookeeper.packets.received metric.
func (mb *MetricsBuilder) zookeeperPacketsReceivedMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.packets.received")
	metric.SetDescription("Number of ZooKeeper packets received by a server.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeSum)
	metric.Sum().SetIsMonotonic(true)
	metric.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	return metric
}

// zookeeperPacketsSentMetric builds new zookeeper.packets.sent metric.
func (mb *MetricsBuilder) zookeeperPacketsSentMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.packets.sent")
	metric.SetDescription("Number of ZooKeeper packets sent by a server.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeSum)
	metric.Sum().SetIsMonotonic(true)
	metric.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	return metric
}

// zookeeperPendingSyncsMetric builds new zookeeper.pending_syncs metric.
func (mb *MetricsBuilder) zookeeperPendingSyncsMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.pending_syncs")
	metric.SetDescription("The number of pending syncs from the followers. Only exposed by the leader.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// zookeeperSyncedFollowersMetric builds new zookeeper.synced_followers metric.
func (mb *MetricsBuilder) zookeeperSyncedFollowersMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.synced_followers")
	metric.SetDescription("The number of followers in sync with the leader. Only exposed by the leader.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// zookeeperWatchesMetric builds new zookeeper.watches metric.
func (mb *MetricsBuilder) zookeeperWatchesMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.watches")
	metric.SetDescription("Number of watches placed on Z-Nodes on a ZooKeeper server.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// zookeeperZnodesMetric builds new zookeeper.znodes metric.
func (mb *MetricsBuilder) zookeeperZnodesMetric() pdata.Metric {
	metric := pdata.NewMetric()
	metric.SetName("zookeeper.znodes")
	metric.SetDescription("Number of z-nodes that a ZooKeeper server has in its data tree.")
	metric.SetUnit("1")
	metric.SetDataType(pdata.MetricDataTypeGauge)
	return metric
}

// clearMetrics clears metrics structure.
func (mb *MetricsBuilder) clearMetrics() {
	if mb.config.ZookeeperApproximateDateSize.Enabled {
		// TODO: Use mb.metrics.ZookeeperApproximateDateSize.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperApproximateDateSize = mb.zookeeperApproximateDateSizeMetric()
	}
	if mb.config.ZookeeperConnectionsAlive.Enabled {
		// TODO: Use mb.metrics.ZookeeperConnectionsAlive.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperConnectionsAlive = mb.zookeeperConnectionsAliveMetric()
	}
	if mb.config.ZookeeperEphemeralNodes.Enabled {
		// TODO: Use mb.metrics.ZookeeperEphemeralNodes.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperEphemeralNodes = mb.zookeeperEphemeralNodesMetric()
	}
	if mb.config.ZookeeperFollowers.Enabled {
		// TODO: Use mb.metrics.ZookeeperFollowers.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperFollowers = mb.zookeeperFollowersMetric()
	}
	if mb.config.ZookeeperFsyncThresholdExceeds.Enabled {
		// TODO: Use mb.metrics.ZookeeperFsyncThresholdExceeds.Sum().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperFsyncThresholdExceeds = mb.zookeeperFsyncThresholdExceedsMetric()
	}
	if mb.config.ZookeeperLatencyAvg.Enabled {
		// TODO: Use mb.metrics.ZookeeperLatencyAvg.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperLatencyAvg = mb.zookeeperLatencyAvgMetric()
	}
	if mb.config.ZookeeperLatencyMax.Enabled {
		// TODO: Use mb.metrics.ZookeeperLatencyMax.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperLatencyMax = mb.zookeeperLatencyMaxMetric()
	}
	if mb.config.ZookeeperLatencyMin.Enabled {
		// TODO: Use mb.metrics.ZookeeperLatencyMin.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperLatencyMin = mb.zookeeperLatencyMinMetric()
	}
	if mb.config.ZookeeperMaxFileDescriptors.Enabled {
		// TODO: Use mb.metrics.ZookeeperMaxFileDescriptors.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperMaxFileDescriptors = mb.zookeeperMaxFileDescriptorsMetric()
	}
	if mb.config.ZookeeperOpenFileDescriptors.Enabled {
		// TODO: Use mb.metrics.ZookeeperOpenFileDescriptors.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperOpenFileDescriptors = mb.zookeeperOpenFileDescriptorsMetric()
	}
	if mb.config.ZookeeperOutstandingRequests.Enabled {
		// TODO: Use mb.metrics.ZookeeperOutstandingRequests.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperOutstandingRequests = mb.zookeeperOutstandingRequestsMetric()
	}
	if mb.config.ZookeeperPacketsReceived.Enabled {
		// TODO: Use mb.metrics.ZookeeperPacketsReceived.Sum().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperPacketsReceived = mb.zookeeperPacketsReceivedMetric()
	}
	if mb.config.ZookeeperPacketsSent.Enabled {
		// TODO: Use mb.metrics.ZookeeperPacketsSent.Sum().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperPacketsSent = mb.zookeeperPacketsSentMetric()
	}
	if mb.config.ZookeeperPendingSyncs.Enabled {
		// TODO: Use mb.metrics.ZookeeperPendingSyncs.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperPendingSyncs = mb.zookeeperPendingSyncsMetric()
	}
	if mb.config.ZookeeperSyncedFollowers.Enabled {
		// TODO: Use mb.metrics.ZookeeperSyncedFollowers.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperSyncedFollowers = mb.zookeeperSyncedFollowersMetric()
	}
	if mb.config.ZookeeperWatches.Enabled {
		// TODO: Use mb.metrics.ZookeeperWatches.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperWatches = mb.zookeeperWatchesMetric()
	}
	if mb.config.ZookeeperZnodes.Enabled {
		// TODO: Use mb.metrics.ZookeeperZnodes.Gauge().DataPoints().Clear() instead of rebuilding
		// the metrics once the Clear method is available.
		mb.metrics.ZookeeperZnodes = mb.zookeeperZnodesMetric()
	}
}

// RecordZookeeperApproximateDateSizeDataPoint adds a data point to zookeeper.approximate_date_size metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperApproximateDateSizeDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperApproximateDateSize.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperApproximateDateSize.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperConnectionsAliveDataPoint adds a data point to zookeeper.connections_alive metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperConnectionsAliveDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperConnectionsAlive.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperConnectionsAlive.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperEphemeralNodesDataPoint adds a data point to zookeeper.ephemeral_nodes metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperEphemeralNodesDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperEphemeralNodes.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperEphemeralNodes.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperFollowersDataPoint adds a data point to zookeeper.followers metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperFollowersDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperFollowers.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperFollowers.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperFsyncThresholdExceedsDataPoint adds a data point to zookeeper.fsync_threshold_exceeds metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperFsyncThresholdExceedsDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperFsyncThresholdExceeds.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperFsyncThresholdExceeds.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperLatencyAvgDataPoint adds a data point to zookeeper.latency.avg metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperLatencyAvgDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperLatencyAvg.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperLatencyAvg.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperLatencyMaxDataPoint adds a data point to zookeeper.latency.max metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperLatencyMaxDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperLatencyMax.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperLatencyMax.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperLatencyMinDataPoint adds a data point to zookeeper.latency.min metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperLatencyMinDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperLatencyMin.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperLatencyMin.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperMaxFileDescriptorsDataPoint adds a data point to zookeeper.max_file_descriptors metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperMaxFileDescriptorsDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperMaxFileDescriptors.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperMaxFileDescriptors.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperOpenFileDescriptorsDataPoint adds a data point to zookeeper.open_file_descriptors metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperOpenFileDescriptorsDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperOpenFileDescriptors.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperOpenFileDescriptors.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperOutstandingRequestsDataPoint adds a data point to zookeeper.outstanding_requests metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperOutstandingRequestsDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperOutstandingRequests.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperOutstandingRequests.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperPacketsReceivedDataPoint adds a data point to zookeeper.packets.received metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperPacketsReceivedDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperPacketsReceived.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperPacketsReceived.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperPacketsSentDataPoint adds a data point to zookeeper.packets.sent metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperPacketsSentDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperPacketsSent.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperPacketsSent.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperPendingSyncsDataPoint adds a data point to zookeeper.pending_syncs metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperPendingSyncsDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperPendingSyncs.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperPendingSyncs.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperSyncedFollowersDataPoint adds a data point to zookeeper.synced_followers metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperSyncedFollowersDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperSyncedFollowers.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperSyncedFollowers.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperWatchesDataPoint adds a data point to zookeeper.watches metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperWatchesDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperWatches.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperWatches.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// RecordZookeeperZnodesDataPoint adds a data point to zookeeper.znodes metric.
// Any attribute of AttributeValueTypeEmpty type will be skipped.
func (mb *MetricsBuilder) RecordZookeeperZnodesDataPoint(ts pdata.Timestamp, val int64) {
	if !mb.config.ZookeeperZnodes.Enabled {
		return
	}

	dp := mb.metrics.ZookeeperZnodes.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(mb.startTime)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// ServerState (State of the Zookeeper server (leader, standalone or follower).)
	ServerState string
	// ZkVersion (Zookeeper version of the instance.)
	ZkVersion string
}{
	"server.state",
	"zk.version",
}

// A is an alias for Attributes.
var A = Attributes
